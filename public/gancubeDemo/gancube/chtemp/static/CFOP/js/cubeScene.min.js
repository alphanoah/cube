function cubeData() {
    return {
        faces: ['left', 'right', 'top', 'bottom', 'back', 'front'],
        colors: ['blue', 'green', 'white', 'yellow', 'red', 'orange'],
        pivotTransform: {rotateX: -35, rotateY: -135},
        codes: [],
        extendCodes: [],
        formulaCode: "",
        demoCode: "",
        formula: [],
        curFormula: 0,
        intervalTime: 300,
        passedPower: 2.5,
        scramblingCode: [],
        pieces: [],
        id: 0,
        timer: [],
        stop: false,
    }
}

var cubeModule = new Vue({
    el: '#cubeScene',
    data: cubeData,
    mounted: function () {
        this.assembleCube()
    },
    methods: {
        makeCodes() {
            this.codes = [];
            this.extendCodes = [];
            for (let i = 0; i < 6; i++) {
                let codeT = {face: i, cw: true};
                let codeF = {face: i, cw: false};
                this.codes = this.codes.concat(codeT, codeF)
            }
            for (let i = 0; i < 2; i++) {
                let codeT = {middleDir: i, cw: true};
                let codeF = {middleDir: i, cw: false};
                this.extendCodes = this.extendCodes.concat(codeT, codeF)
            }
            ;this.makeFormula()
        }, makeFormula() {
            let formula = [];
            for (let i = 0; i < 25; i++) {
                do {
                    var n = Math.floor((Math.random() * this.codes.length));
                    formula[i] = this.codes[n]
                } while (i > 0 && formula[i].face === formula[i - 1]);
            }
            this.formula = formula;
            this.handleFormula();
            this.runScramblingCode()
        }, conversionFormula: function (str) {
            let formula = [];
            let codeStr = typeof (str) == "string" ? str : this.formulaCode;
            if (!codeStr) {
                return null
            }
            this.formulaCode = codeStr;
            codeStr = codeStr.replace(/\s/, '');
            codeStr = codeStr.replace(/\((.+?)\)2/, '$1$1');
            codeStr = codeStr.replace(/(\w['’]?)2/g, '$1$1');
            codeStr = codeStr.replace(/\((.+?)\)/g, '$1');
            arr = codeStr.match(/(\w['’]?)/g);
            for (let i = 0; i < arr.length; i++) {
                let face = null, cw = true, middleDir, whole;
                let code = arr[i];
                let letter = code[0];
                let letterStr = letter;
                whole = (letter.toLowerCase() === letter) ? 2 : 1;
                letter = letter.toUpperCase();
                switch (letter) {
                    case'B':
                        face = 0;
                        break;
                    case'F':
                        face = 1;
                        break;
                    case'U':
                        face = 2;
                        break;
                    case'D':
                        face = 3;
                        break;
                    case'R':
                        face = 4;
                        break;
                    case'L':
                        face = 5;
                        break;
                    case'M':
                        face = 5;
                        middleDir = true;
                        break;
                    case'E':
                        face = 3;
                        middleDir = true;
                        break;
                    case'S':
                        face = 1;
                        middleDir = true;
                        break;
                    case'X':
                        face = 4;
                        whole = 3;
                        break;
                    case'Y':
                        face = 2;
                        whole = 3;
                        break;
                    case'Z':
                        face = 1;
                        whole = 3;
                        break;
                    default:
                        alert("解析公式出错");
                        return false
                }
                ;(whole > 1) && (middleDir = true);
                cw = (code[1] && (code[1] === '’' || code[1] === "\'")) ? false : true;
                let f = {face: face, cw: cw};
                f.middleDir = !!middleDir;
                f.whole = whole;
                f.letterStr = letterStr + (cw ? "" : "'");
                formula.push(f)
            }
            this.formula = formula;
            this.curFormula = 0
        }, setIntervalTime(dom, hhh) {
            var val = (dom.target.value - 0);
            val = isNaN(val) ? 300 : val || 300;
            val = (val < 40) ? 40 : val;
            this.intervalTime = val
        }, handleFormula() {
            let formula = [];
            const numbers = ["R", "L", "U", "D", "F", "B", "R'", "L'", "U'", "D'", "F'", "B'", "R2", "L2", "U2", "D2", "F2", "B2"];
            for (let i = 0; i < 25; i++) {
                do {
                    var n = Math.floor((Math.random() * numbers.length));
                    formula[i] = numbers[n]
                } while (i > 0 && formula[i].split('')[0] === formula[i - 1].split('')[0])
            }
            ;let makeFormula = formula.join(' ');
            this.$emit('sendFormula', makeFormula)
        }, stickerClass(index, piece) {
            for (let i = 0; i < piece.sticker.length; i++) {
                if (index === piece.sticker[i].num) {
                    return piece.sticker[i].color
                }
            }
            return false
        }, piecesEach(fn) {
            for (let i = 0; i < this.pieces.length; i++) {
                fn.call(this, this.pieces[i], i)
            }
        }, changeStickerColor(id, sticker) {
            this.piecesEach(function (pieces) {
                if (id === pieces.id) {
                    for (let n = 0; n < pieces.sticker.length; n++) {
                        if (sticker) {
                            if (sticker.num === pieces.sticker[n].num) {
                                pieces.sticker[n].color = sticker.color
                            }
                        } else {
                            pieces.sticker[n].color = this.colors[pieces.sticker[n].num]
                        }
                    }
                    return pieces.sticker
                }
            })
        }, initialStickerColor() {
            this.piecesEach(function (piece) {
                for (sticker of piece.sticker) {
                    sticker.color = "none"
                }
            })
        }, batchChangeColor(newSticker) {
            for (stickers of newSticker) {
                if (Array.isArray(stickers.sticker)) {
                    for (sti of stickers.sticker) {
                        this.changeStickerColor(stickers.id, sti)
                    }
                } else {
                    this.changeStickerColor(stickers.id)
                }
            }
        }, demoStickerColor: function (newSticker) {
            this.preventAnimate();
            this.prevStickerColor = newSticker;
            this.initialStickerColor();
            this.batchChangeColor(newSticker);
            this.curFormula = 0
        }, mx(i, j) {
            return ([2, 4, 3, 5][j % 4 | 0] + i % 2 * ((j | 0) % 4 * 2 + 3) + 2 * (i / 2 | 0)) % 6
        }, assembleCube() {
            for (var x, i = 0; i < 26; i++) {
                var piecesParams = {};
                piecesParams.sticker = [];
                x = this.mx(i, i % 18);
                piecesParams.initTransform = 'rotateX(0deg) ' + this.moveTo(i % 6, i, piecesParams) + (i > 5 ? this.moveTo(x, i, piecesParams) + ' ' + (i > 17 ? this.moveTo(this.mx(x, x + 2), i, piecesParams) : '') : '');
                piecesParams.id = this.id;
                piecesParams.className = (i < 6) ? "centerPieces" : ((i > 5 && i <= 17) ? "edgePieces" : "hornPieces");
                if (i > 5 && i <= 17) {
                    let orientClass = "";
                    orientClass = " orient";
                    switch (i % 6) {
                        case 0:
                            orientClass += " orient0";
                            break;
                        case 1:
                            orientClass += " orient1";
                            break;
                        case 2:
                            orientClass += " orient2";
                            break;
                        case 3:
                            orientClass += " orient3";
                            break;
                        case 4:
                            orientClass += " orient4";
                            break;
                        case 5:
                            orientClass += " orient5";
                            break;
                        default:
                            break
                    }
                    if (i > 11) {
                        orientClass += " orientRev"
                    }
                    piecesParams.className += orientClass
                }
                this.id = 0;
                piecesParams.i = i;
                Vue.set(this.pieces, i, piecesParams)
            }
        }, getAxis(face) {
            return String.fromCharCode('X'.charCodeAt(0) + face / 2)
        }, moveTo(face, i, piecesParams) {
            this.id = this.id + (1 << face);
            let stickerParams = {num: face, color: this.colors[face]};
            piecesParams.sticker.push(stickerParams);
            piecesParams.id = this.id;
            return 'translate' + this.getAxis(face) + '(' + (face % 2 * 4 - 2) + 'em)'
        }, stickerShow(index, piece) {
            for (let i = 0; i < piece.sticker.length; i++) {
                if (index === piece.sticker[i].num) {
                    return true
                }
            }
            return false
        }, touchStart(md) {
            var scene = document.getElementById('scene');
            var rotateX = this.pivotTransform.rotateX;
            var rotateY = this.pivotTransform.rotateY;
            var touchMove = (event) => {
                event.preventDefault();
                event.stopPropagation();
                this.pivotTransform.rotateX = rotateX - (event.touches[0].pageY - md.touches[0].pageY) / 2;
                var threshold = Math.abs(rotateX % 360);
                if (threshold > 90 && threshold < 270) {
                    this.pivotTransform.rotateY = rotateY - (mm.pageX - md.pageX) / 2
                } else {
                    this.pivotTransform.rotateY = rotateY + (event.touches[0].pageX - md.touches[0].pageX) / 2
                }
            };
            var touchEnd = function () {
                document.removeEventListener('touchmove', touchMove);
                document.removeEventListener('touchend', touchEnd);
                scene.addEventListener('touchstart', this.touchstart)
            };
            document.addEventListener('touchmove', touchMove, {passive: false});
            document.addEventListener('touchend', touchEnd);
            scene.removeEventListener('touchstart', this.touchstart)
        }, mousedown(md) {
            var scene = document.getElementById('scene');
            var rotateX = this.pivotTransform.rotateX;
            var rotateY = this.pivotTransform.rotateY;
            var mousemove = (mm) => {
                mm.preventDefault();
                this.pivotTransform.rotateX = rotateX - (mm.pageY - md.pageY) / 2;
                var threshold = Math.abs(rotateX % 360);
                if (threshold > 90 && threshold < 270) {
                    this.pivotTransform.rotateY = rotateY - (mm.pageX - md.pageX) / 2
                } else {
                    this.pivotTransform.rotateY = rotateY + (mm.pageX - md.pageX) / 2
                }
            };
            var mouseup = function (e) {
                document.removeEventListener('mousemove', mousemove);
                document.removeEventListener('mouseup', mouseup);
                scene.addEventListener('mousedown', this.mousedown)
            };
            document.addEventListener('mousemove', mousemove);
            document.addEventListener('mouseup', mouseup);
            scene.removeEventListener('mousedown', this.mousedown)
        }, animateRotation(face, cw, currentTime, middleDir, whole, callback) {
            var k = 0.3 * (face % 2 * 2 - 1) * (2 * cw - 1);
            var pieces = document.getElementsByClassName('piece');
            var arr = Array(9).fill(pieces[face]);
            var qubes = [];
            if (whole == 3) {
                qubes = [].concat.apply([], pieces)
            } else {
                for (let i = 0; i < arr.length; i++) {
                    if (whole == 2) {
                        qubes.push(this.getPieceBy(face, i / 2, i % 2, false));
                        middleDir == true
                    }
                    if (i == 8 && (!middleDir || whole == 2)) {
                        qubes.push(document.getElementById('piece' + (1 << face)));
                        continue
                    }
                    qubes.push(this.getPieceBy(face, i / 2, i % 2, middleDir))
                }
            }
            var rotatePieces = () => {
                var passed = Date.now() - currentTime;
                passed = passed * this.passedPower;
                var style = 'rotate' + this.getAxis(face) + '(' + k * passed * (passed < 300) + 'deg)';
                qubes.forEach(function (piece) {
                    piece.style.transform = piece.style.transform.replace(/rotate.\(\S+\)/, style)
                });
                if (passed >= 300) {
                    this.swapPieces(face, 3 - 2 * cw, middleDir, whole);
                    callback && callback.call(this);
                    return
                }
                ;requestAnimationFrame(rotatePieces)
            };
            rotatePieces()
        }, preventAnimate() {
            this.stop = true;
            this.timer && this.timer.forEach(function (t) {
                clearTimeout(t)
            })
        }, getPieceBy(face, index, corner, isMiddle, backFace) {
            return document.getElementById('piece' + (((1 << (backFace != undefined ? backFace : face)) * !isMiddle) + (1 << this.mx(face, index)) + (1 << this.mx(face, index + 1)) * corner))
        }, getPieceIdBy(face, index, corner, isMiddle, backFace) {
            return ((1 << (backFace != undefined ? backFace : face)) * !isMiddle) + (1 << this.mx(face, index)) + (1 << this.mx(face, index + 1)) * corner
        }, swapPieces(face, times, middleDir, whole) {
            var isWhole = whole > 1;
            var backFace = (face % 2) ? face - 1 : face + 1;
            for (let w = 0; w < whole; w++) {
                isMiddle = (isWhole && !(w % 2)) ? false : middleDir;
                for (var i = 0; i < 6 * times; i++) {
                    var piece1 = [];
                    var piece2 = [];
                    var self = this;
                    pieceId1 = this.getPieceIdBy(face, i / 2, i % 2, isMiddle, (w == 2 ? backFace : undefined));
                    pieceId2 = this.getPieceIdBy(face, i / 2 + 1, i % 2, isMiddle, (w == 2 ? backFace : undefined));
                    this.pieces.forEach(function (pie) {
                        pie.id === pieceId1 && (piece1 = pie);
                        pie.id === pieceId2 && (piece2 = pie)
                    });
                    for (var j = 0; j < 5; j++) {
                        var sticker1 = null;
                        var sticker2 = null;
                        piece1.sticker.forEach(function (sti) {
                            if (sti.num == (j < 4 ? self.mx(face, j) : (w == 2 ? backFace : face))) {
                                sticker1 = sti
                            }
                        });
                        piece2.sticker.forEach(function (sti) {
                            if (sti.num == (j < 4 ? self.mx(face, j + 1) : (w == 2 ? backFace : face))) {
                                sticker2 = sti
                            }
                        });
                        var color = sticker1 ? sticker1.color : '';
                        if (color) {
                            sticker1.color = sticker2.color;
                            sticker2.color = color
                        }
                    }
                }
                if (!(isMiddle)) {
                    face = (w == 0 ? face : backFace);
                    let centerPie = document.getElementById('piece' + (1 << face));
                    let sticker = centerPie.children[face].querySelector(".sticker");
                    let rotate = sticker.style.transform.match(/rotate\((\d+)deg\)/);
                    if (rotate) {
                        rotate = rotate ? (rotate[1] - 0) : 0;
                        sticker.style.setProperty("transform", "rotate(" + (rotate + 90 * times) % 360 + "deg", "important")
                    } else {
                        sticker.style.setProperty("transform", "rotate(270deg)", "important")
                    }
                }
            }
        }, setScrambling(face, cw) {
            let step = {face: face, cw: cw};
            this.solveCode.push(step)
        }, replaceCode(face, cw) {
            switch (face) {
                case 0:
                    if (cw === false) {
                        return 'B' + '’'
                    } else {
                        return 'B'
                    }
                case 1:
                    if (cw === false) {
                        return 'F' + '’'
                    } else {
                        return 'F'
                    }
                case 2:
                    if (cw === false) {
                        return 'U' + '’'
                    } else {
                        return 'U'
                    }
                case 3:
                    if (cw === false) {
                        return 'D' + '’'
                    } else {
                        return 'D'
                    }
                case 4:
                    if (cw === false) {
                        return 'R' + '’'
                    } else {
                        return 'R'
                    }
                case 5:
                    if (cw === false) {
                        return 'L' + '’'
                    } else {
                        return 'L'
                    }
                default:
                    return '无法识别'
            }
        }, runScramblingCode(single) {
            this.preventAnimate();
            this.stop = false;
            var formula = this.formula;
            var timers = [];
            var reverse = false;
            var index = this.curFormula %= this.formula.length;
            if (single && single === "next") {
                formula = this.formula.slice(index, index + 1)
            } else if (single && single === "prev") {
                if (index == 0) {
                    formula = this.formula.slice(-1)
                } else {
                    formula = this.formula.slice(index - 1, index)
                }
                reverse = true
            } else {
                formula = this.formula.slice(index)
            }
            for (let i = 0; i < formula.length; i++) {
                let f = formula[i];
                timers.push(setTimeout(() => {
                    if (!this.stop) {
                        let callBack = undefined;
                        if (i == formula.length - 1) {
                            callBack = function () {
                                this.stop = true
                            }
                        }
                        this.animateRotation(f.face, (reverse ? !f.cw : f.cw), Date.now(), f.middleDir, f.whole, callBack);
                        if (!reverse) {
                            index = (index + 1)
                        } else {
                            index = (index == 0) ? this.formula.length - 1 : (index - 1)
                        }
                        this.curFormula = index
                    }
                }, this.intervalTime * (i + 1)))
            }
            this.timer = timers
        }, runDemoScramblingCode: function () {
            this.demoStickerColor(this.prevStickerColor);
            this.runScramblingCode()
        },
    },
    computed: {
        pivotMove() {
            return 'rotateX(' + this.pivotTransform.rotateX + 'deg)' + 'rotateY(' + this.pivotTransform.rotateY + 'deg)'
        }, codeIndent() {
            var indent = $('.cubePop .cubeScene .runFormulaCode .codeBox').width() - (this.curFormula + 1) * 28;
            return ((indent > 0) ? 0 : indent) + 'px'
        }
    }
})